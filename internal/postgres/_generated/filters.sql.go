// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: filters.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDepartements = `-- name: GetDepartements :many
SELECT d.id_departement AS id,
       d.nom_departement AS name,
       d.id_region AS region_id,
       r.nom_region AS region_name,
       r.id_pays AS pays_id,
       p.nom_pays AS pays_name
FROM loc_departements d
         JOIN loc_regions r ON d.id_region = r.id_region
         JOIN loc_pays p ON r.id_pays = p.id_pays
WHERE d.nom_departement != '' AND d.nom_departement IS NOT NULL
`

type GetDepartementsRow struct {
	ID         int32
	Name       pgtype.Text
	RegionID   pgtype.Int4
	RegionName pgtype.Text
	PaysID     pgtype.Int4
	PaysName   pgtype.Text
}

func (q *Queries) GetDepartements(ctx context.Context) ([]GetDepartementsRow, error) {
	rows, err := q.db.Query(ctx, getDepartements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDepartementsRow
	for rows.Next() {
		var i GetDepartementsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RegionID,
			&i.RegionName,
			&i.PaysID,
			&i.PaysName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeplacements = `-- name: GetDeplacements :many
SELECT id_mode_deplacement AS id, mode_deplacement_type AS name FROM bib_pers_phy_modes_deplacements WHERE mode_deplacement_type != '' AND mode_deplacement_type IS NOT NULL
`

type GetDeplacementsRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetDeplacements(ctx context.Context) ([]GetDeplacementsRow, error) {
	rows, err := q.db.Query(ctx, getDeplacements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeplacementsRow
	for rows.Next() {
		var i GetDeplacementsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEtatsConservation = `-- name: GetEtatsConservation :many
SELECT id_etat_conservation AS id, etat_conservation_type AS name FROM bib_etats_conservation WHERE etat_conservation_type != '' AND etat_conservation_type IS NOT NULL
`

type GetEtatsConservationRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetEtatsConservation(ctx context.Context) ([]GetEtatsConservationRow, error) {
	rows, err := q.db.Query(ctx, getEtatsConservation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEtatsConservationRow
	for rows.Next() {
		var i GetEtatsConservationRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHistoricalPeriods = `-- name: GetHistoricalPeriods :many
SELECT id_periode_historique AS id, periode_historique_type AS name FROM bib_pers_phy_periodes_historiques WHERE periode_historique_type != '' AND periode_historique_type IS NOT NULL
`

type GetHistoricalPeriodsRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetHistoricalPeriods(ctx context.Context) ([]GetHistoricalPeriodsRow, error) {
	rows, err := q.db.Query(ctx, getHistoricalPeriods)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHistoricalPeriodsRow
	for rows.Next() {
		var i GetHistoricalPeriodsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMateriaux = `-- name: GetMateriaux :many
SELECT id_materiau AS id, materiau_type AS name FROM bib_materiaux WHERE materiau_type != '' AND materiau_type IS NOT NULL
`

type GetMateriauxRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetMateriaux(ctx context.Context) ([]GetMateriauxRow, error) {
	rows, err := q.db.Query(ctx, getMateriaux)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMateriauxRow
	for rows.Next() {
		var i GetMateriauxRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNaturesMob = `-- name: GetNaturesMob :many
SELECT id_nature AS id, nature_type AS name FROM bib_mob_img_natures WHERE nature_type != '' AND nature_type IS NOT NULL
`

type GetNaturesMobRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetNaturesMob(ctx context.Context) ([]GetNaturesMobRow, error) {
	rows, err := q.db.Query(ctx, getNaturesMob)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNaturesMobRow
	for rows.Next() {
		var i GetNaturesMobRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNaturesMonu = `-- name: GetNaturesMonu :many
SELECT id_monu_lieu_nature AS id, monu_lieu_nature_type AS name FROM bib_monu_lieu_natures WHERE monu_lieu_nature_type != '' AND monu_lieu_nature_type IS NOT NULL
`

type GetNaturesMonuRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetNaturesMonu(ctx context.Context) ([]GetNaturesMonuRow, error) {
	rows, err := q.db.Query(ctx, getNaturesMonu)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNaturesMonuRow
	for rows.Next() {
		var i GetNaturesMonuRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNaturesPersonnesMorales = `-- name: GetNaturesPersonnesMorales :many
SELECT id_pers_mo_nature AS id, pers_mo_nature_type AS name FROM bib_pers_mo_natures WHERE pers_mo_nature_type != '' AND pers_mo_nature_type IS NOT NULL
`

type GetNaturesPersonnesMoralesRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetNaturesPersonnesMorales(ctx context.Context) ([]GetNaturesPersonnesMoralesRow, error) {
	rows, err := q.db.Query(ctx, getNaturesPersonnesMorales)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNaturesPersonnesMoralesRow
	for rows.Next() {
		var i GetNaturesPersonnesMoralesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPays = `-- name: GetPays :many
SELECT id_pays AS id, nom_pays AS name FROM loc_pays WHERE nom_pays != '' AND nom_pays IS NOT NULL
`

type GetPaysRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetPays(ctx context.Context) ([]GetPaysRow, error) {
	rows, err := q.db.Query(ctx, getPays)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaysRow
	for rows.Next() {
		var i GetPaysRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfessions = `-- name: GetProfessions :many
SELECT id_profession AS id, profession_type AS name FROM bib_pers_phy_professions WHERE profession_type != '' AND profession_type IS NOT NULL
`

type GetProfessionsRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetProfessions(ctx context.Context) ([]GetProfessionsRow, error) {
	rows, err := q.db.Query(ctx, getProfessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProfessionsRow
	for rows.Next() {
		var i GetProfessionsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegions = `-- name: GetRegions :many
SELECT r.id_region AS id,
       r.nom_region AS name,
       r.id_pays AS pays_id,
       p.nom_pays AS pays_name
FROM loc_regions r
         JOIN loc_pays p ON r.id_pays = p.id_pays
WHERE r.nom_region != '' AND r.nom_region IS NOT NULL
`

type GetRegionsRow struct {
	ID       int32
	Name     pgtype.Text
	PaysID   pgtype.Int4
	PaysName pgtype.Text
}

func (q *Queries) GetRegions(ctx context.Context) ([]GetRegionsRow, error) {
	rows, err := q.db.Query(ctx, getRegions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRegionsRow
	for rows.Next() {
		var i GetRegionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PaysID,
			&i.PaysName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSiecles = `-- name: GetSiecles :many
SELECT id_siecle AS id, siecle_list AS name FROM bib_siecle WHERE siecle_list != '' AND siecle_list IS NOT NULL ORDER BY id_siecle ASC
`

type GetSieclesRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetSiecles(ctx context.Context) ([]GetSieclesRow, error) {
	rows, err := q.db.Query(ctx, getSiecles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSieclesRow
	for rows.Next() {
		var i GetSieclesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTechniquesMob = `-- name: GetTechniquesMob :many
SELECT id_technique AS id, technique_type AS name FROM bib_mob_img_techniques WHERE technique_type != '' AND technique_type IS NOT NULL
`

type GetTechniquesMobRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetTechniquesMob(ctx context.Context) ([]GetTechniquesMobRow, error) {
	rows, err := q.db.Query(ctx, getTechniquesMob)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTechniquesMobRow
	for rows.Next() {
		var i GetTechniquesMobRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThemes = `-- name: GetThemes :many
SELECT id_theme AS id, theme_type AS name FROM t_themes WHERE theme_type != '' AND theme_type IS NOT NULL
`

type GetThemesRow struct {
	ID   int32
	Name pgtype.Text
}

func (q *Queries) GetThemes(ctx context.Context) ([]GetThemesRow, error) {
	rows, err := q.db.Query(ctx, getThemes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThemesRow
	for rows.Next() {
		var i GetThemesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCommunesPaginated = `-- name: SearchCommunesPaginated :many
SELECT
    c.id_commune AS id,
    c.nom_commune AS commune_name,
    c.id_departement AS departement_id,
    d.nom_departement AS departement_name,
    d.id_region AS region_id,
    r.nom_region AS region_name,
    r.id_pays AS pays_id,
    p.nom_pays AS pays_name
FROM loc_communes c
         JOIN loc_departements d ON c.id_departement = d.id_departement
         JOIN loc_regions r ON d.id_region = r.id_region
         JOIN loc_pays p ON r.id_pays = p.id_pays
WHERE c.nom_commune != '' AND c.nom_commune IS NOT NULL AND c.nom_commune ILIKE $1
ORDER BY c.nom_commune ASC
LIMIT $2 OFFSET $3
`

type SearchCommunesPaginatedParams struct {
	NomCommune pgtype.Text
	Limit      int32
	Offset     int32
}

type SearchCommunesPaginatedRow struct {
	ID              int32
	CommuneName     pgtype.Text
	DepartementID   pgtype.Int4
	DepartementName pgtype.Text
	RegionID        pgtype.Int4
	RegionName      pgtype.Text
	PaysID          pgtype.Int4
	PaysName        pgtype.Text
}

func (q *Queries) SearchCommunesPaginated(ctx context.Context, arg SearchCommunesPaginatedParams) ([]SearchCommunesPaginatedRow, error) {
	rows, err := q.db.Query(ctx, searchCommunesPaginated, arg.NomCommune, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCommunesPaginatedRow
	for rows.Next() {
		var i SearchCommunesPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.CommuneName,
			&i.DepartementID,
			&i.DepartementName,
			&i.RegionID,
			&i.RegionName,
			&i.PaysID,
			&i.PaysName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
