// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: personnes_morales.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const attachAuthorToPersMo = `-- name: AttachAuthorToPersMo :exec
INSERT INTO cor_auteur_fiche_pers_mo
    (auteur_fiche_pers_mo_id, pers_morale_id)
VALUES ($1, $2)
`

type AttachAuthorToPersMoParams struct {
	AuteurID int32
	ID       int32
}

func (q *Queries) AttachAuthorToPersMo(ctx context.Context, arg AttachAuthorToPersMoParams) error {
	_, err := q.db.Exec(ctx, attachAuthorToPersMo, arg.AuteurID, arg.ID)
	return err
}

const attachMediasToPersMo = `-- name: AttachMediasToPersMo :exec
INSERT INTO cor_medias_pers_mo
    (media_pers_mo_id, pers_morale_id)
SELECT unnest($1::int[]), $2
`

type AttachMediasToPersMoParams struct {
	MediaIds []int32
	ID       int32
}

func (q *Queries) AttachMediasToPersMo(ctx context.Context, arg AttachMediasToPersMoParams) error {
	_, err := q.db.Exec(ctx, attachMediasToPersMo, arg.MediaIds, arg.ID)
	return err
}

const attachNaturesToPersMo = `-- name: AttachNaturesToPersMo :exec
INSERT INTO cor_natures_pers_mo (pers_mo_nature_id, pers_morale_id)
SELECT unnest($1::int[]), $2
`

type AttachNaturesToPersMoParams struct {
	NatureIds []int32
	ID        int32
}

func (q *Queries) AttachNaturesToPersMo(ctx context.Context, arg AttachNaturesToPersMoParams) error {
	_, err := q.db.Exec(ctx, attachNaturesToPersMo, arg.NatureIds, arg.ID)
	return err
}

const attachSieclesToPersMo = `-- name: AttachSieclesToPersMo :exec
INSERT INTO cor_siecles_pers_mo
    (siecle_pers_mo_id, pers_morale_id)
SELECT unnest($1::int[]), $2
`

type AttachSieclesToPersMoParams struct {
	SiecleID []int32
	ID       int32
}

func (q *Queries) AttachSieclesToPersMo(ctx context.Context, arg AttachSieclesToPersMoParams) error {
	_, err := q.db.Exec(ctx, attachSieclesToPersMo, arg.SiecleID, arg.ID)
	return err
}

const attachThemesToPersMo = `-- name: AttachThemesToPersMo :exec
INSERT INTO cor_themes_pers_mo (theme_id, pers_mo_id)
SELECT unnest($1::int[]), $2
`

type AttachThemesToPersMoParams struct {
	ThemeIds []int32
	ID       int32
}

func (q *Queries) AttachThemesToPersMo(ctx context.Context, arg AttachThemesToPersMoParams) error {
	_, err := q.db.Exec(ctx, attachThemesToPersMo, arg.ThemeIds, arg.ID)
	return err
}

const createPersMorale = `-- name: CreatePersMorale :one
INSERT INTO t_pers_morales
(titre_pers_mo,
 commentaires,
 historique,
 acte_fondation,
 simple_mention,
 texte_statuts,
 fonctionnement,
 participation_vie_soc,
 objets,
 bibliographie,
 sources,
 date_creation,
 date_maj,
 contributeurs,
 id_commune,
 id_pays,
 publie,
 publication_status,
 parent_id)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        NOW(),
        NOW(),
        $12,
        $13,
        $14,
        false,
        'DRAFT',
        $15)
RETURNING id_pers_morale
`

type CreatePersMoraleParams struct {
	Title               pgtype.Text
	Comment             pgtype.Text
	Historique          pgtype.Text
	ActeFondation       pgtype.Bool
	SimpleMention       pgtype.Bool
	TexteStatuts        pgtype.Bool
	Fonctionnement      pgtype.Text
	ParticipationVieSoc pgtype.Text
	Objets              pgtype.Text
	Bibliographie       pgtype.Text
	Sources             pgtype.Text
	Contributeurs       pgtype.Text
	IDCommune           pgtype.Int4
	IDPays              pgtype.Int4
	ParentID            pgtype.Int4
}

func (q *Queries) CreatePersMorale(ctx context.Context, arg CreatePersMoraleParams) (int32, error) {
	row := q.db.QueryRow(ctx, createPersMorale,
		arg.Title,
		arg.Comment,
		arg.Historique,
		arg.ActeFondation,
		arg.SimpleMention,
		arg.TexteStatuts,
		arg.Fonctionnement,
		arg.ParticipationVieSoc,
		arg.Objets,
		arg.Bibliographie,
		arg.Sources,
		arg.Contributeurs,
		arg.IDCommune,
		arg.IDPays,
		arg.ParentID,
	)
	var id_pers_morale int32
	err := row.Scan(&id_pers_morale)
	return id_pers_morale, err
}

const deletePendingPersonneMorale = `-- name: DeletePendingPersonneMorale :exec
DELETE
FROM t_pers_morales
WHERE id_pers_morale = $1
`

func (q *Queries) DeletePendingPersonneMorale(ctx context.Context, idPersMorale int32) error {
	_, err := q.db.Exec(ctx, deletePendingPersonneMorale, idPersMorale)
	return err
}

const detachAuthorFromPersMo = `-- name: DetachAuthorFromPersMo :exec
DELETE
FROM cor_auteur_fiche_pers_mo
WHERE pers_morale_id = $1
`

func (q *Queries) DetachAuthorFromPersMo(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, detachAuthorFromPersMo, id)
	return err
}

const detachMediasFromPersMo = `-- name: DetachMediasFromPersMo :exec
DELETE
FROM cor_medias_pers_mo
WHERE pers_morale_id = $1
`

func (q *Queries) DetachMediasFromPersMo(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, detachMediasFromPersMo, id)
	return err
}

const detachNaturesFromPersMo = `-- name: DetachNaturesFromPersMo :exec
DELETE
FROM cor_natures_pers_mo
WHERE pers_morale_id = $1
`

func (q *Queries) DetachNaturesFromPersMo(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, detachNaturesFromPersMo, id)
	return err
}

const detachSieclesFromPersMo = `-- name: DetachSieclesFromPersMo :exec
DELETE
FROM cor_siecles_pers_mo
WHERE pers_morale_id = $1
`

func (q *Queries) DetachSieclesFromPersMo(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, detachSieclesFromPersMo, id)
	return err
}

const detachThemesFromPersMo = `-- name: DetachThemesFromPersMo :exec
DELETE
FROM cor_themes_pers_mo
WHERE pers_mo_id = $1
`

func (q *Queries) DetachThemesFromPersMo(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, detachThemesFromPersMo, id)
	return err
}

const getFilteredPersonnesMorales = `-- name: GetFilteredPersonnesMorales :many
SELECT p.id_pers_morale AS id,
       p.titre_pers_mo  AS title,
       COALESCE(array_agg(DISTINCT bs.siecle_list) FILTER (WHERE bs.siecle_list IS NOT NULL),
                '{}')   AS siecles,
       COALESCE(array_agg(DISTINCT bpn.pers_mo_nature_type) FILTER (WHERE bpn.pers_mo_nature_type IS NOT NULL),
                '{}')   AS natures,
       COALESCE(array_agg(DISTINCT tm.chemin_media) FILTER (WHERE tm.chemin_media IS NOT NULL),
                '{}')   AS medias
FROM t_pers_morales p
         LEFT JOIN cor_siecles_pers_mo csp ON p.id_pers_morale = csp.pers_morale_id
         LEFT JOIN bib_siecle bs ON bs.id_siecle = csp.siecle_pers_mo_id

         LEFT JOIN cor_natures_pers_mo cnp ON p.id_pers_morale = cnp.pers_morale_id
         LEFT JOIN bib_pers_mo_natures bpn ON bpn.id_pers_mo_nature = cnp.pers_mo_nature_id

         LEFT JOIN cor_medias_mob_img cme ON p.id_pers_morale = cme.mobilier_image_id
         LEFT JOIN t_medias tm ON tm.id_media = cme.media_mob_img_id

         LEFT JOIN loc_communes c ON p.id_commune = c.id_commune
         LEFT JOIN loc_departements d ON c.id_departement = d.id_departement
         LEFT JOIN loc_regions r ON d.id_region = r.id_region
         LEFT JOIN loc_pays pa ON r.id_pays = pa.id_pays

         LEFT JOIN cor_auteur_fiche_pers_mo caf ON p.id_pers_morale = caf.pers_morale_id
         LEFT JOIN cor_mob_img_pers_mo cpm ON p.id_pers_morale = cpm.pers_morale_id
         LEFT JOIN cor_pers_phy_pers_mo cpp ON p.id_pers_morale = cpp.pers_morale_id
         LEFT JOIN cor_monu_lieu_pers_mo cmi ON p.id_pers_morale = cmi.pers_morale_id
WHERE (cardinality($1::int[]) = 0 OR csp.siecle_pers_mo_id = ANY ($1::int[]))
   OR (cardinality($2::int[]) = 0 OR cnp.pers_mo_nature_id = ANY ($2::int[]))
   OR (cardinality($3::int[]) = 0 OR
       caf.auteur_fiche_pers_mo_id = ANY ($3::int[]))
   OR (cardinality($4::int[]) = 0 OR cpp.pers_physique_id = ANY ($4::int[]))
   OR (cardinality($5::int[]) = 0 OR cmi.monument_lieu_id = ANY ($5::int[]))
   OR (cardinality($6::int[]) = 0 OR cpm.mobilier_image_id = ANY ($6::int[]))
   OR (cardinality($7::int[]) = 0 OR c.id_commune = ANY ($7::int[]))
   OR (cardinality($8::int[]) = 0 OR d.id_departement = ANY ($8::int[]))
   OR (cardinality($9::int[]) = 0 OR r.id_region = ANY ($9::int[]))
   OR (cardinality($10::int[]) = 0 OR pa.id_pays = ANY ($10::int[]))
GROUP BY p.id_pers_morale
ORDER BY p.id_pers_morale
LIMIT $12 OFFSET $11
`

type GetFilteredPersonnesMoralesParams struct {
	Siecles      []int32
	Natures      []int32
	AuteursFiche []int32
	PersPhy      []int32
	Places       []int32
	Furniture    []int32
	Cities       []int32
	Departments  []int32
	Regions      []int32
	Pays         []int32
	OffsetParam  int32
	LimitParam   int32
}

type GetFilteredPersonnesMoralesRow struct {
	ID      int32
	Title   pgtype.Text
	Siecles interface{}
	Natures interface{}
	Medias  interface{}
}

func (q *Queries) GetFilteredPersonnesMorales(ctx context.Context, arg GetFilteredPersonnesMoralesParams) ([]GetFilteredPersonnesMoralesRow, error) {
	rows, err := q.db.Query(ctx, getFilteredPersonnesMorales,
		arg.Siecles,
		arg.Natures,
		arg.AuteursFiche,
		arg.PersPhy,
		arg.Places,
		arg.Furniture,
		arg.Cities,
		arg.Departments,
		arg.Regions,
		arg.Pays,
		arg.OffsetParam,
		arg.LimitParam,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredPersonnesMoralesRow
	for rows.Next() {
		var i GetFilteredPersonnesMoralesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Siecles,
			&i.Natures,
			&i.Medias,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPersonnesMorales = `-- name: GetPendingPersonnesMorales :many
SELECT p.id_pers_morale       AS id,
       p.titre_pers_mo        AS title,
       p.acte_fondation       AS foundation_deed,
       p.historique,
       p.bibliographie,
       p.simple_mention,
       p.fonctionnement,
       p.participation_vie_soc,
       p.objets,
       p.sources,
       p.date_creation,
       p.date_maj,
       p.publie,
       p.contributeurs,
       p.commentaires,
       -- Redacteurs (auteurs fiche)
       COALESCE(array_agg(DISTINCT baf.auteur_fiche_nom) FILTER (WHERE baf.auteur_fiche_nom IS NOT NULL),
                '{}')         AS redacteurs,
       -- Commune
       MAX(c.nom_commune)     AS commune,
       -- Département
       MAX(d.nom_departement) AS departement,
       -- Région
       MAX(r.nom_region)      AS region,
       -- Pays
       MAX(pa.nom_pays)       AS pays,
       -- Natures
       COALESCE(array_agg(DISTINCT bpn.pers_mo_nature_type) FILTER (WHERE bpn.pers_mo_nature_type IS NOT NULL),
                '{}')         AS natures,
       -- Médias
       COALESCE(
                       jsonb_agg(
                       DISTINCT jsonb_build_object(
                               'id', tm.id_media,
                               'titre', tm.titre_media
                                )
                                ) FILTER (
                           WHERE tm.chemin_media IS NOT NULL
                       AND tm.chemin_media <> ''
                       AND tm.chemin_media <> '[]'
                       AND EXISTS (SELECT 1
                                   FROM jsonb_array_elements(tm.chemin_media::jsonb) AS elem
                                   WHERE COALESCE(elem ->> 'path', '') <> '')
                           ),
                       '[]'::jsonb
       )                      AS medias,
       -- Monuments lieux (IDs uniquement)
       COALESCE(array_agg(DISTINCT cml.monument_lieu_id) FILTER (WHERE cml.monument_lieu_id IS NOT NULL),
                '{}')         AS monuments_lieux_liees,
       -- Mobiliers images (IDs uniquement)
       COALESCE(array_agg(DISTINCT cpm.mobilier_image_id) FILTER (WHERE cpm.mobilier_image_id IS NOT NULL),
                '{}')         AS mobiliers_images_liees,
       -- Personnes physiques (IDs uniquement)
       COALESCE(array_agg(DISTINCT cpp.pers_physique_id) FILTER (WHERE cpp.pers_physique_id IS NOT NULL),
                '{}')         AS personnes_physiques_liees,
       -- Siècles
       COALESCE(array_agg(DISTINCT bs.siecle_list) FILTER (WHERE bs.siecle_list IS NOT NULL),
                '{}')         AS siecles,
       -- Themes
       COALESCE(array_agg(DISTINCT t.theme_type) FILTER (WHERE t.theme_type IS NOT NULL),
                '{}')         AS themes
FROM t_pers_morales p
         LEFT JOIN cor_auteur_fiche_pers_mo cap ON p.id_pers_morale = cap.pers_morale_id
         LEFT JOIN bib_auteurs baf ON cap.auteur_fiche_pers_mo_id = baf.id_auteur_fiche
         LEFT JOIN loc_communes c ON p.id_commune = c.id_commune
         LEFT JOIN loc_departements d ON c.id_departement = d.id_departement
         LEFT JOIN loc_regions r ON d.id_region = r.id_region
         LEFT JOIN loc_pays pa ON r.id_pays = p.id_pays
         LEFT JOIN cor_medias_pers_mo cmp ON p.id_pers_morale = cmp.pers_morale_id
         LEFT JOIN cor_natures_pers_mo cnp ON p.id_pers_morale = cnp.pers_morale_id
         LEFT JOIN bib_pers_mo_natures bpn ON cnp.pers_mo_nature_id = bpn.id_pers_mo_nature
         LEFT JOIN t_medias tm ON cmp.media_pers_mo_id = tm.id_media
         LEFT JOIN cor_monu_lieu_pers_mo cml ON p.id_pers_morale = cml.pers_morale_id
         LEFT JOIN cor_mob_img_pers_mo cpm ON p.id_pers_morale = cpm.pers_morale_id
         LEFT JOIN cor_pers_phy_pers_mo cpp ON p.id_pers_morale = cpp.pers_morale_id
         LEFT JOIN cor_siecles_pers_mo csp ON p.id_pers_morale = csp.pers_morale_id
         LEFT JOIN bib_siecle bs ON csp.siecle_pers_mo_id = bs.id_siecle
         LEFT JOIN cor_themes_pers_mo ctpm ON p.id_pers_morale = ctpm.pers_mo_id
         LEFT JOIN t_themes t ON t.id_theme = ctpm.theme_id
WHERE p.publication_status = 'DRAFT'
   or p.publication_status = 'PENDING'
GROUP BY p.id_pers_morale
`

type GetPendingPersonnesMoralesRow struct {
	ID                      int32
	Title                   pgtype.Text
	FoundationDeed          pgtype.Bool
	Historique              pgtype.Text
	Bibliographie           pgtype.Text
	SimpleMention           pgtype.Bool
	Fonctionnement          pgtype.Text
	ParticipationVieSoc     pgtype.Text
	Objets                  pgtype.Text
	Sources                 pgtype.Text
	DateCreation            pgtype.Date
	DateMaj                 pgtype.Date
	Publie                  pgtype.Bool
	Contributeurs           pgtype.Text
	Commentaires            pgtype.Text
	Redacteurs              interface{}
	Commune                 interface{}
	Departement             interface{}
	Region                  interface{}
	Pays                    interface{}
	Natures                 interface{}
	Medias                  interface{}
	MonumentsLieuxLiees     interface{}
	MobiliersImagesLiees    interface{}
	PersonnesPhysiquesLiees interface{}
	Siecles                 interface{}
	Themes                  interface{}
}

func (q *Queries) GetPendingPersonnesMorales(ctx context.Context) ([]GetPendingPersonnesMoralesRow, error) {
	rows, err := q.db.Query(ctx, getPendingPersonnesMorales)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingPersonnesMoralesRow
	for rows.Next() {
		var i GetPendingPersonnesMoralesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.FoundationDeed,
			&i.Historique,
			&i.Bibliographie,
			&i.SimpleMention,
			&i.Fonctionnement,
			&i.ParticipationVieSoc,
			&i.Objets,
			&i.Sources,
			&i.DateCreation,
			&i.DateMaj,
			&i.Publie,
			&i.Contributeurs,
			&i.Commentaires,
			&i.Redacteurs,
			&i.Commune,
			&i.Departement,
			&i.Region,
			&i.Pays,
			&i.Natures,
			&i.Medias,
			&i.MonumentsLieuxLiees,
			&i.MobiliersImagesLiees,
			&i.PersonnesPhysiquesLiees,
			&i.Siecles,
			&i.Themes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonneMoraleByID = `-- name: GetPersonneMoraleByID :one
SELECT p.id_pers_morale  AS id,
       p.titre_pers_mo   AS title,
       p.acte_fondation  AS foundation_deed,
       p.historique,
       p.bibliographie,
       p.simple_mention,
       p.fonctionnement,
       p.participation_vie_soc,
       p.objets,
       p.sources,
       p.date_creation,
       p.date_maj,
       p.publie,
       p.contributeurs,
       p.commentaires,
       -- Redacteurs (auteurs fiche)
       COALESCE(array_agg(DISTINCT baf.auteur_fiche_nom) FILTER (WHERE baf.auteur_fiche_nom IS NOT NULL),
                '{}')    AS redacteurs,
       -- Commune
       c.nom_commune     AS commune,
       -- Département
       d.nom_departement AS departement,
       -- Région
       r.nom_region      AS region,
       -- Pays
       pa.nom_pays       AS pays,
       -- Natures
       COALESCE(array_agg(DISTINCT bpn.pers_mo_nature_type) FILTER (WHERE bpn.pers_mo_nature_type IS NOT NULL),
                '{}')    AS natures,
       -- Médias
       COALESCE(
                       jsonb_agg(
                       DISTINCT jsonb_build_object(
                               'id', tm.id_media,
                               'titre', tm.titre_media
                                )
                                ) FILTER (
                           WHERE tm.chemin_media IS NOT NULL
                       AND tm.chemin_media <> ''
                       AND tm.chemin_media <> '[]'
                       AND EXISTS (SELECT 1
                                   FROM jsonb_array_elements(tm.chemin_media::jsonb) AS elem
                                   WHERE COALESCE(elem ->> 'path', '') <> '')
                           ),
                       '[]'::jsonb
       )                 AS medias,
       -- Monuments lieux (IDs uniquement)
       COALESCE(array_agg(DISTINCT cml.monument_lieu_id) FILTER (WHERE cml.monument_lieu_id IS NOT NULL),
                '{}')    AS monuments_lieux_liees,
       -- Mobiliers images (IDs uniquement)
       COALESCE(array_agg(DISTINCT cpm.mobilier_image_id) FILTER (WHERE cpm.mobilier_image_id IS NOT NULL),
                '{}')    AS mobiliers_images_liees,
       -- Personnes physiques (IDs uniquement)
       COALESCE(array_agg(DISTINCT cpp.pers_physique_id) FILTER (WHERE cpp.pers_physique_id IS NOT NULL),
                '{}')    AS personnes_physiques_liees,
       -- Siècles
       COALESCE(array_agg(DISTINCT bs.siecle_list) FILTER (WHERE bs.siecle_list IS NOT NULL),
                '{}')    AS siecles,
       -- Themes
       COALESCE(array_agg(DISTINCT t.theme_type) FILTER (WHERE t.theme_type IS NOT NULL),
                '{}')    AS themes,
       publication_status,
       parent_id
FROM t_pers_morales p
         LEFT JOIN cor_auteur_fiche_pers_mo cap ON p.id_pers_morale = cap.pers_morale_id
         LEFT JOIN bib_auteurs baf ON cap.auteur_fiche_pers_mo_id = baf.id_auteur_fiche
         LEFT JOIN loc_communes c ON p.id_commune = c.id_commune
         LEFT JOIN loc_departements d ON c.id_departement = d.id_departement
         LEFT JOIN loc_regions r ON d.id_region = r.id_region
         LEFT JOIN loc_pays pa ON r.id_pays = p.id_pays
         LEFT JOIN cor_medias_pers_mo cmp ON p.id_pers_morale = cmp.pers_morale_id
         LEFT JOIN cor_natures_pers_mo cnp ON p.id_pers_morale = cnp.pers_morale_id
         LEFT JOIN bib_pers_mo_natures bpn ON cnp.pers_mo_nature_id = bpn.id_pers_mo_nature
         LEFT JOIN t_medias tm ON cmp.media_pers_mo_id = tm.id_media
         LEFT JOIN cor_monu_lieu_pers_mo cml ON p.id_pers_morale = cml.pers_morale_id
         LEFT JOIN cor_mob_img_pers_mo cpm ON p.id_pers_morale = cpm.pers_morale_id
         LEFT JOIN cor_pers_phy_pers_mo cpp ON p.id_pers_morale = cpp.pers_morale_id
         LEFT JOIN cor_siecles_pers_mo csp ON p.id_pers_morale = csp.pers_morale_id
         LEFT JOIN bib_siecle bs ON csp.siecle_pers_mo_id = bs.id_siecle
         LEFT JOIN cor_themes_pers_mo ctpm ON p.id_pers_morale = ctpm.pers_mo_id
         LEFT JOIN t_themes t ON t.id_theme = ctpm.theme_id
WHERE p.id_pers_morale = $1
GROUP BY p.id_pers_morale,
         c.nom_commune,
         d.nom_departement,
         r.nom_region,
         pa.nom_pays
`

type GetPersonneMoraleByIDRow struct {
	ID                      int32
	Title                   pgtype.Text
	FoundationDeed          pgtype.Bool
	Historique              pgtype.Text
	Bibliographie           pgtype.Text
	SimpleMention           pgtype.Bool
	Fonctionnement          pgtype.Text
	ParticipationVieSoc     pgtype.Text
	Objets                  pgtype.Text
	Sources                 pgtype.Text
	DateCreation            pgtype.Date
	DateMaj                 pgtype.Date
	Publie                  pgtype.Bool
	Contributeurs           pgtype.Text
	Commentaires            pgtype.Text
	Redacteurs              interface{}
	Commune                 pgtype.Text
	Departement             pgtype.Text
	Region                  pgtype.Text
	Pays                    pgtype.Text
	Natures                 interface{}
	Medias                  interface{}
	MonumentsLieuxLiees     interface{}
	MobiliersImagesLiees    interface{}
	PersonnesPhysiquesLiees interface{}
	Siecles                 interface{}
	Themes                  interface{}
	PublicationStatus       PublicationStatus
	ParentID                pgtype.Int4
}

func (q *Queries) GetPersonneMoraleByID(ctx context.Context, idPersMorale int32) (GetPersonneMoraleByIDRow, error) {
	row := q.db.QueryRow(ctx, getPersonneMoraleByID, idPersMorale)
	var i GetPersonneMoraleByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.FoundationDeed,
		&i.Historique,
		&i.Bibliographie,
		&i.SimpleMention,
		&i.Fonctionnement,
		&i.ParticipationVieSoc,
		&i.Objets,
		&i.Sources,
		&i.DateCreation,
		&i.DateMaj,
		&i.Publie,
		&i.Contributeurs,
		&i.Commentaires,
		&i.Redacteurs,
		&i.Commune,
		&i.Departement,
		&i.Region,
		&i.Pays,
		&i.Natures,
		&i.Medias,
		&i.MonumentsLieuxLiees,
		&i.MobiliersImagesLiees,
		&i.PersonnesPhysiquesLiees,
		&i.Siecles,
		&i.Themes,
		&i.PublicationStatus,
		&i.ParentID,
	)
	return i, err
}

const linkPersMoToMobImg = `-- name: LinkPersMoToMobImg :exec
INSERT INTO cor_mob_img_pers_mo
    (pers_morale_id, mobilier_image_id)
SELECT $1, unnest($2::int[])
`

type LinkPersMoToMobImgParams struct {
	ID        int32
	MobImgIds []int32
}

func (q *Queries) LinkPersMoToMobImg(ctx context.Context, arg LinkPersMoToMobImgParams) error {
	_, err := q.db.Exec(ctx, linkPersMoToMobImg, arg.ID, arg.MobImgIds)
	return err
}

const linkPersMoToMonuLieu = `-- name: LinkPersMoToMonuLieu :exec
INSERT INTO cor_monu_lieu_pers_mo
    (pers_morale_id, monument_lieu_id)
SELECT $1, unnest($2::int[])
`

type LinkPersMoToMonuLieuParams struct {
	ID          int32
	MonuLieuIds []int32
}

func (q *Queries) LinkPersMoToMonuLieu(ctx context.Context, arg LinkPersMoToMonuLieuParams) error {
	_, err := q.db.Exec(ctx, linkPersMoToMonuLieu, arg.ID, arg.MonuLieuIds)
	return err
}

const linkPersMoToPersPhy = `-- name: LinkPersMoToPersPhy :exec
INSERT INTO cor_pers_phy_pers_mo
    (pers_morale_id, pers_physique_id)
SELECT $1, unnest($2::int[])
`

type LinkPersMoToPersPhyParams struct {
	ID          int32
	PersoPhyIds []int32
}

func (q *Queries) LinkPersMoToPersPhy(ctx context.Context, arg LinkPersMoToPersPhyParams) error {
	_, err := q.db.Exec(ctx, linkPersMoToPersPhy, arg.ID, arg.PersoPhyIds)
	return err
}

const unlinkPersMoFromMobImg = `-- name: UnlinkPersMoFromMobImg :exec
DELETE
FROM cor_mob_img_pers_mo
WHERE pers_morale_id = $1
`

func (q *Queries) UnlinkPersMoFromMobImg(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, unlinkPersMoFromMobImg, id)
	return err
}

const unlinkPersMoFromMonuLieu = `-- name: UnlinkPersMoFromMonuLieu :exec
DELETE
FROM cor_monu_lieu_pers_mo
WHERE pers_morale_id = $1
`

func (q *Queries) UnlinkPersMoFromMonuLieu(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, unlinkPersMoFromMonuLieu, id)
	return err
}

const unlinkPersMoFromPersPhy = `-- name: UnlinkPersMoFromPersPhy :exec
DELETE
FROM cor_pers_phy_pers_mo
WHERE pers_morale_id = $1
`

func (q *Queries) UnlinkPersMoFromPersPhy(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, unlinkPersMoFromPersPhy, id)
	return err
}

const validatePendingPersonneMorales = `-- name: ValidatePendingPersonneMorales :exec
UPDATE t_pers_morales
SET publication_status = 'PUBLISHED',
    publie             = true,
    parent_id          = NULL
WHERE id_pers_morale = $1
`

func (q *Queries) ValidatePendingPersonneMorales(ctx context.Context, idPersMorale int32) error {
	_, err := q.db.Exec(ctx, validatePendingPersonneMorales, idPersMorale)
	return err
}
